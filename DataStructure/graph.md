# 1. Graph의 정의

그래프는 `정점(Vertex)`과 그 사이를 잇는 `간선(Edge)`으로 구성된 자료구조를 의미한다.

<br>

# 2. Graph의 종류

그래프 내에 특정한 방향이 없다면 `무방향 그래프`라고 불리며 한 쪽 방향으로만 갈 수 있다면 `방향 그래프`라고 불린다.

무방향 그래프의 경우 A라는 정점이 있다고 가정할 때, A와 연결된 정점의 수를 `차수(Degree)` 라고 부른다.

방향 그래프의 경우 들어올 수 있는 정점의 수와 나갈 수 있는 정점의 수가 다르기 때문에 `진입차수(In-degree)`와 `진출차수(Out-degree)`로 구분해서 부른다.

<img width="618" alt="Image" src="https://github.com/user-attachments/assets/6e68e597-82e9-4618-9177-d95caf189991" />

<br>
<br>


그래프의 간선에는 값이 적혀 있는 경우도 있는데 이러한 값을 `간선의 가중치`라고 부른다.

아래와 같은 그래프는 `가중치 그래프`라고 부른다.

![Image](https://github.com/user-attachments/assets/8f404242-9390-4741-b33b-6bfcd60fa3ac)

가중치 그래프는 방향 그래프일 수도 있고, 무방향 그래프일 수도 있다.

<br>

그래프의 특정 지점에서 출발하여 다시 원래 지점으로 돌아올 수 있다면 우리는 그래프에 `사이클(Cycle)`이 있다고 한다.

<img width="343" alt="Image" src="https://github.com/user-attachments/assets/e11cb690-abf0-4707-a393-e6fb378150a4" />

⏫ 사이클이 있는 그래프

<br>

연결 관계에 따라 그래프는 `연결 그래프`와 `비연결 그래프`로 나누어지기도 한다.

이때 그래프에서 하나의 간선으로 연결되어 있는 정점들을 전부 묶었을 때 만들어지는 그룹을 `연결 요소`라고 부른다.

<img width="618" alt="Image" src="https://github.com/user-attachments/assets/1505eec7-42b1-47d1-b1d3-ca56252ee15d" />

++) 트리도 그래프의 한 종류이다.

<br>

<aside>


### 🔎 용어 정리

    - 정점(Vertex): 노드(node), 데이터 저장
    - 간선(Edge): 정점을 연결하는 선
    - 차수(degree): 무방향 그래프에서 하나의 정점에 붙어있는 간선의 개수
    - 진출 차수(out-degree): 방향 그래프의 정점에서 나가는 간선의 수
    - 진입 차수(in-degree): 방향 그래프의 정점에 들어오는 간선의 수
</aside>

<br>
<br>

# 3. Graph 구현

그래프를 구현하는 방식은 인접 행렬과 인접 리스트 두 가지가 있다.

<br>

### 2-1. 인접 행렬로 그래프 만들기

**|V|** : 정점의 수

**|E|** : 간선의 수

인접 행렬은 |V| x |V| 크기의 **2차원 배열**을 만들어서 연결 관계를 표현하는 것이다. 즉, A → B 로 가는 길이 있다면 배열의 값을 1로, 없다면 배열의 값을 0으로 저장하게 된다.

<img width="618" alt="Image" src="https://github.com/user-attachments/assets/2102809c-7f42-40da-8f98-c1933073ccb2" />

- 그래프를 인접 행렬로 구현 했을 때 시간 복잡도
    - 특정 두 정점이 연결되어 있는지 확인: O(1)

        → 배열로 이루어져 있기 때문에 graph[i][j]의 값을 바로 확인 가능

    - 특정 정점과 연결되어 있는 모든 정점을 확인: O($N^2$)

        → N*N 만큼 반복문을 돌아 확인

<br>


### 2-2. 인접 리스트로 그래프 만들기

인접 리스트는 |V|개의 연결 리스트를 만들고, 연결 리스트에 특정 정점과 인접해 있는 정점들의 정보를 담는 식이다.

예를 들어 아래의 방향 그래프 그림에서 3번 노드의 연결 리스트 길이는 2가 된다.

<img width="618" alt="Image" src="https://github.com/user-attachments/assets/fab0bed9-eca9-4645-9e65-2e1e0491a4af" />


무방향 그래프의 경우는 다음과 같다.

![Image](https://github.com/user-attachments/assets/0f05d376-76f4-4a68-a217-8d79794930f6)

- 그래프를 인접 리스트로 구현 했을 때 시간 복잡도
    - 특정 두 정점 i, j가 연결되어 있는지 확인: O(min(degree(i), degree(j)))

        → 정점 i나 j에 있는 연결 리스트를 순회하면서 i 또는 j를 찾으면 되기 때문이다. 쉽게 말해 i또는 j의 차수만큼 시간이 필요하다.

    - 특정 정점과 연결되어 있는 모든 정점을 확인: O(degree(V))

        → 정점의 인접 리스트를 탐색해야 하므로 정점의 차수만큼 시간이 필요하다.

<br>
<br>


# 4. 인접 행렬과 인접 리스트의 장단점

### 3-1. 인접 행렬의 장단점

- **장점** : 두 정점의 연결 여부를 확인하기 쉽다.

- **단점**: 간선의 수와 무관하게 항상 $N^2$크기의 2차원 배열이 필요하므로 메모리 공간이 낭비되기 쉽다.

또한, 그래프의 모든 간선의 수를 알아내려면 인접 행렬 전체를 확인해야 하므로 O($N^2$) 의 시간이 소요된다.

### 3-2. 인접 리스트의 장단점

- **장점**: 존재하는 간선만 관리 하므로 메모리 사용이 효율적이다.

- **단점**: 두 노드를 연결하는 간선을 조회하거나 노드의 차수를 알기 위해서는 노드의 인접 리스트를 탐색해야 하므로 노드의 차수만큼 시간이 필요하다.

<br>

정리하자면,

간선이 많은 그래프일 경우, **인접 행렬을** 통해 빠르게 **연결 여부**를 확인할 수 있다.

반면, 간선이 적은 그래프의 경우는 **인접 리스트**를 통해 **인접 노드**를 빠르게 확인할 수 있다.

<br>
<br>

# 5. Graph를 이용한 알고리즘

### 5-1. 그래프 탐색

가중치가 없는 그래프를 탐색할 때 주로 사용 되는 알고리즘은 다음과 같다.

- DFS(깊이 우선 탐색, Depth-First-Search)
- BFS(너비 우선 탐색, Breadth-First-Search)

<br>

### 5-2. 최소 신장 트리

`신장 트리` 는 그래프 G의 부분 그래프로서 G의 모든 정점을 포함하는 트리이다.

![Image](https://github.com/user-attachments/assets/b0516bfe-e848-432c-9226-6d1c8e0ddea0)

`최소 신장 트리` 는 간선에 가중치가 주어졌을 때 G의 신장 트리 중 간선의 가중치 합이 최소가 되는 신장 트리이다.

![Image](https://github.com/user-attachments/assets/34661dd6-2428-45dc-956f-2390eebcefbd)

최소 신장 트리를 사용하는 대표적인 알고리즘 2가지

- 크루스칼(Kruskal) 알고리즘
- 프림(Prim) 알고리즘

<br>

### 5-3. 최단 경로

`최단 경로`란 가중치 그래프가 있다면 출발지에서 도착지까지 경로의 간선 가중치 합이 최소인 경우다.

가중치가 있는 그래프의 최단 경로를 구하는 알고리즘은 다음과 같다.

- 다익스트라(Dijkstra) 알고리즘
- 벨만-포드(Bellman-Ford) 알고리즘
- 플로이드-와샬(Floyd-Warshall)알고리즘